main.py:

from fastapi import FastAPI, Depends, HTTPException
from sqlalchemy.orm import Session

from database import SessionLocal, engine, Base
from services import (
    patient_service,
    doctor_service,
    appointment_service,
)
from schemas import (
    patient_pydantic,
    doctor_pydantic,
    appointment_pydantic,
)

app = FastAPI(title="Patient Encounter System")


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


@app.on_event("startup")
def startup_event():
    Base.metadata.create_all(bind=engine)


@app.post("/patients", response_model=patient_pydantic.PatientRead, status_code=201)
def create_patient(
    patient: patient_pydantic.PatientCreate,
    db: Session = Depends(get_db),
):
    try:
        db_patient = patient_service.create_patient(db, patient)
        return db_patient
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))


@app.get("/patients/{patient_id}", response_model=patient_pydantic.PatientRead)
def read_patient(patient_id: int, db: Session = Depends(get_db)):
    patient = patient_service.read_patient(db, patient_id)
    if not patient:
        raise HTTPException(status_code=404, detail="Patient not found")
    return patient_pydantic.PatientRead(**patient)


@app.get("/patients", response_model=list[patient_pydantic.PatientRead])
def read_all_patients(db: Session = Depends(get_db)):
    patients = patient_service.read_all_patients(db)
    return [patient_pydantic.PatientRead(**p) for p in patients]


@app.post("/doctors", response_model=doctor_pydantic.DoctorRead, status_code=201)
def create_doctor(
    doctor: doctor_pydantic.DoctorCreate,
    db: Session = Depends(get_db),
):
    db_doctor = doctor_service.create_doctor(db, doctor)
    return db_doctor


@app.get("/doctors/{doctor_id}", response_model=doctor_pydantic.DoctorRead)
def read_doctor(doctor_id: int, db: Session = Depends(get_db)):
    doctor = doctor_service.read_doctor(db, doctor_id)
    if not doctor:
        raise HTTPException(status_code=404, detail="Doctor not found")
    return doctor_pydantic.DoctorRead(**doctor)


@app.get("/doctors", response_model=list[doctor_pydantic.DoctorRead])
def read_all_doctors(db: Session = Depends(get_db)):
    doctors = doctor_service.read_all_doctors(db)
    return [doctor_pydantic.DoctorRead(**d) for d in doctors]


@app.put(
    "/doctors/{doctor_id}/toggle-status", response_model=doctor_pydantic.DoctorRead
)
def toggle_status_doctor(doctor_id: int, db: Session = Depends(get_db)):
    db_doctor = doctor_service.toggle_status_doctor(db, doctor_id)
    if not db_doctor:
        raise HTTPException(status_code=404, detail="Doctor not found")
    return db_doctor


@app.post(
    "/appointments",
    response_model=appointment_pydantic.AppointmentRead,
    status_code=201,
)
def create_appointment(
    appointment: appointment_pydantic.AppointmentCreate,
    db: Session = Depends(get_db),
):
    try:
        db_appointment = appointment_service.create_appointment(db, appointment)
        return db_appointment
    except ValueError as e:
        raise HTTPException(status_code=409, detail=str(e))


@app.get(
    "/appointments/by-date", response_model=list[appointment_pydantic.AppointmentRead]
)
def read_appointments_for_a_date(date: str, db: Session = Depends(get_db)):
    appointments = appointment_service.read_appointments_for_a_date(db, date)
    return [appointment_pydantic.AppointmentRead.from_orm(app) for app in appointments]


@app.get(
    "/appointments",
    response_model=list[appointment_pydantic.AppointmentDetailedRead],
)
def list_appointments(
    doctor_id: int | None = None,
    patient_id: int | None = None,
    date: str | None = None,
    db: Session = Depends(get_db),
):
    appointments = appointment_service.list_appointments(
        db, doctor_id, patient_id, date
    )
    return [appointment_pydantic.AppointmentDetailedRead(**a) for a in appointments]


@app.delete("/patients/{patient_id}", status_code=204)
def delete_patient(patient_id: int, db: Session = Depends(get_db)):
    try:
        result = patient_service.delete_patient(db, patient_id)
        if not result:
            raise HTTPException(404, "Patient not found")
    except ValueError as e:
        raise HTTPException(409, str(e))


@app.delete("/doctors/{doctor_id}", status_code=204)
def delete_doctor(doctor_id: int, db: Session = Depends(get_db)):
    try:
        result = doctor_service.delete_doctor(db, doctor_id)
        if not result:
            raise HTTPException(404, "Doctor not found")
    except ValueError as e:
        raise HTTPException(409, str(e))


@app.delete("/appointments/{appointment_id}", status_code=204)
def delete_appointment(appointment_id: int, db: Session = Depends(get_db)):
    try:
        result = appointment_service.delete_appointment(db, appointment_id)
        if not result:
            raise HTTPException(404, "Appointment not found")
    except ValueError as e:
        raise HTTPException(409, str(e))


database.py:
import os
from sqlalchemy import create_engine
from sqlalchemy.orm import DeclarativeBase, sessionmaker
from dotenv import load_dotenv

load_dotenv()
DATABASE_URL = "sqlite:///./app.db"  # fallback for CI

if not DATABASE_URL:
    raise RuntimeError("DATABASE_URL is not set")

engine = create_engine(
    DATABASE_URL,
    pool_pre_ping=True,
    pool_size=5,
    max_overflow=10,
)

SessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)


class Base(DeclarativeBase):
    pass


create_tables.py:
# ruff: noqa: F401

from database import engine
from database import Base

# IMPORTANT: import all models so SQLAlchemy knows them
from models.patient import Patient
from models.doctor import Doctor
from models.appointment import Appointment


def create_tables():
    Base.metadata.create_all(bind=engine)
    print(" Tables created successfully")


if __name__ == "__main__":
    create_tables()


check_tables.py:
from sqlalchemy import inspect
from database import engine


def check_tables():
    inspector = inspect(engine)
    tables = inspector.get_table_names()
    print("Tables in DB:", tables)


if __name__ == "__main__":
    check_tables()


src/models/appointment.py:
# ruff: noqa: E402

from datetime import datetime
from database import Base
from sqlalchemy import (
    DateTime,
    ForeignKey,
    Integer,
    func,
)
from sqlalchemy.orm import (
    Mapped,
    mapped_column,
    relationship,
)


class Appointment(Base):
    """
    Represents an appointment between a patient and a doctor.
    """

    __tablename__ = "vamsi_appointments"

    id: Mapped[int] = mapped_column(primary_key=True)

    patient_id: Mapped[int] = mapped_column(
        ForeignKey("vamsi_patients.id"), nullable=False
    )

    doctor_id: Mapped[int] = mapped_column(
        ForeignKey("vamsi_doctors.id"), nullable=False
    )

    appointment_start_datetime: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), nullable=False, index=True
    )

    appointment_duration_minutes: Mapped[int] = mapped_column(Integer, nullable=False)

    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), nullable=False, server_default=func.now()
    )

    patient: Mapped["Patient"] = relationship("Patient", back_populates="appointments")

    doctor: Mapped["Doctor"] = relationship("Doctor", back_populates="appointments")


from models.patient import Patient
from models.doctor import Doctor

src/models/doctor.py:
# ruff: noqa: E402
from datetime import datetime

from sqlalchemy import String, Boolean, DateTime, func
from sqlalchemy.orm import Mapped, mapped_column, relationship

from database import Base


class Doctor(Base):
    """
    Represents a doctor in the hospital.
    """

    __tablename__ = "vamsi_doctors"

    id: Mapped[int] = mapped_column(primary_key=True)

    full_name: Mapped[str] = mapped_column(String(100), nullable=False)

    specialty: Mapped[str] = mapped_column(String(100), nullable=False)

    active_status: Mapped[bool] = mapped_column(
        Boolean, nullable=False, server_default="1"  # MySQL: 1 = true
    )

    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), nullable=False, server_default=func.now()
    )

    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
        server_default=func.now(),
        onupdate=func.now(),
    )

    appointments: Mapped[list["Appointment"]] = relationship(back_populates="doctor")


from models.appointment import Appointment


src/models/patient.py:
# ruff: noqa: E402
from datetime import datetime

from sqlalchemy import String, Boolean, DateTime, func
from sqlalchemy.orm import Mapped, mapped_column, relationship

from database import Base


class Doctor(Base):
    """
    Represents a doctor in the hospital.
    """

    __tablename__ = "vamsi_doctors"

    id: Mapped[int] = mapped_column(primary_key=True)

    full_name: Mapped[str] = mapped_column(String(100), nullable=False)

    specialty: Mapped[str] = mapped_column(String(100), nullable=False)

    active_status: Mapped[bool] = mapped_column(
        Boolean, nullable=False, server_default="1"  # MySQL: 1 = true
    )

    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), nullable=False, server_default=func.now()
    )

    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
        server_default=func.now(),
        onupdate=func.now(),
    )

    appointments: Mapped[list["Appointment"]] = relationship(back_populates="doctor")


from models.appointment import Appointment


src/schemas/appointmnet_pydnatic.py:
from pydantic import BaseModel, field_validator, computed_field, PositiveInt
from datetime import datetime, timezone, timedelta


class AppointmentCreate(BaseModel):
    patient_id: PositiveInt
    doctor_id: PositiveInt
    appointment_start_datetime: datetime
    appointment_duration_minutes: int

    @field_validator("appointment_start_datetime")
    @classmethod
    def must_be_timezone_aware(cls, value: datetime):
        if value.tzinfo is None or value.tzinfo.utcoffset(value) is None:
            raise ValueError("appointment_start_datetime must be timezone-aware")

        now = datetime.now(timezone.utc)
        if value <= now:
            raise ValueError("appointment_start_datetime must be in the future")

        return value

    @field_validator("appointment_duration_minutes")
    @classmethod
    def duration_must_be_valid(cls, value: int):
        if value < 15 or value > 180:
            raise ValueError("appointment_duration_minutes must be between 15 and 180")
        return value


class AppointmentRead(BaseModel):
    id: PositiveInt
    patient_id: PositiveInt
    doctor_id: PositiveInt
    appointment_start_datetime: datetime
    appointment_duration_minutes: int
    created_at: datetime

    class Config:
        from_attributes = True

    @computed_field
    def appointment_end_datetime(self) -> datetime:
        return self.appointment_start_datetime + timedelta(
            minutes=self.appointment_duration_minutes
        )


class AppointmentDetailedRead(BaseModel):
    appointment_id: PositiveInt
    appointment_start_datetime: datetime
    appointment_duration_minutes: int
    created_at: datetime

    patient_id: PositiveInt
    patient_first_name: str
    patient_last_name: str
    patient_email: str

    doctor_id: PositiveInt
    doctor_full_name: str
    doctor_specialty: str

    class Config:
        from_attributes = True

    @computed_field
    def appointment_end_datetime(self) -> datetime:
        return self.appointment_start_datetime + timedelta(
            minutes=self.appointment_duration_minutes
        )


src/schemas/doctor_pydantic.py:
from pydantic import BaseModel, PositiveInt
from datetime import datetime
from typing import Optional


class DoctorCreate(BaseModel):
    full_name: str
    specialty: str
    active_status: Optional[bool] = True


class DoctorRead(BaseModel):
    id: PositiveInt
    full_name: str
    specialty: str
    active_status: bool
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


src/schemas/patient_pydantic.py:
from pydantic import BaseModel, PositiveInt
from datetime import datetime
from pydantic import EmailStr


class PatientCreate(BaseModel):
    first_name: str
    last_name: str
    email: EmailStr
    phone_number: str


class PatientRead(BaseModel):
    id: PositiveInt
    first_name: str
    last_name: str
    email: EmailStr
    phone_number: str
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True




src/services/appointment_service.py:
from datetime import datetime, timedelta, timezone, date
from sqlalchemy.orm import Session
from sqlalchemy import select
from models.appointment import Appointment
from models.doctor import Doctor
from models.patient import Patient
from fastapi import HTTPException
from schemas import appointment_pydantic as sch

# ------------------------
# Helpers
# ------------------------


def _as_utc(dt: datetime) -> datetime:
    """
    Normalize datetime to UTC.
    If DB gives naive datetime, treat it as UTC.
    """
    if dt.tzinfo is None:
        return dt.replace(tzinfo=timezone.utc)
    return dt.astimezone(timezone.utc)


def create_appointment(db: Session, appointment: sch.AppointmentCreate):

    # ---- existence checks ----
    patient = db.get(Patient, appointment.patient_id)
    if not patient:
        raise HTTPException(status_code=409, detail="Patient not found")

    doctor = db.get(Doctor, appointment.doctor_id)
    if not doctor:
        raise HTTPException(status_code=409, detail="Doctor not found")

    if not doctor.active_status:
        raise HTTPException(
            status_code=409,
            detail="Doctor is inactive and cannot accept appointments",
        )

    # ---- time normalization ----
    new_start = _as_utc(appointment.appointment_start_datetime)
    now = datetime.now(timezone.utc)

    if new_start <= now:
        raise HTTPException(
            status_code=422,
            detail="appointment_start_datetime must be in the future",
        )

    new_end = new_start + timedelta(
        minutes=appointment.appointment_duration_minutes
    )

    # ---- CONFLICT LOGIC (THIS IS WHAT FACULTY CHECKS) ----
    existing_appointments = db.scalars(
        select(Appointment).where(
            Appointment.doctor_id == appointment.doctor_id
        )
    ).all()

    for appt in existing_appointments:
        existing_start = _as_utc(appt.appointment_start_datetime)
        existing_end = existing_start + timedelta(
            minutes=appt.appointment_duration_minutes
        )

        # overlap condition
        if new_start < existing_end and new_end > existing_start:
            raise HTTPException(
                status_code=409,
                detail="Doctor already has an overlapping appointment",
            )

    # ---- create appointment ----
    db_appointment = Appointment(
        patient_id=appointment.patient_id,
        doctor_id=appointment.doctor_id,
        appointment_start_datetime=new_start,
        appointment_duration_minutes=appointment.appointment_duration_minutes,
    )

    db.add(db_appointment)
    db.commit()
    db.refresh(db_appointment)
    return db_appointment

# ------------------------
# Read / List / Delete
# ------------------------


def read_appointment(db: Session, appointment_id: int):
    stmt = (
        select(
            Appointment.id.label("appointment_id"),
            Appointment.appointment_start_datetime,
            Appointment.appointment_duration_minutes,
            Appointment.created_at,
            Patient.id.label("patient_id"),
            Patient.first_name.label("patient_first_name"),
            Patient.last_name.label("patient_last_name"),
            Patient.email.label("patient_email"),
            Doctor.id.label("doctor_id"),
            Doctor.full_name.label("doctor_full_name"),
            Doctor.specialty.label("doctor_specialty"),
        )
        .join(Patient, Patient.id == Appointment.patient_id)
        .join(Doctor, Doctor.id == Appointment.doctor_id)
        .where(Appointment.id == appointment_id)
    )

    return db.execute(stmt).mappings().one_or_none()


def list_appointments(
    db: Session,
    doctor_id: int | None = None,
    patient_id: int | None = None,
    date_str: str | None = None,
):
    stmt = (
        select(
            Appointment.id.label("appointment_id"),
            Appointment.appointment_start_datetime,
            Appointment.appointment_duration_minutes,
            Appointment.created_at,
            Patient.id.label("patient_id"),
            Patient.first_name.label("patient_first_name"),
            Patient.last_name.label("patient_last_name"),
            Patient.email.label("patient_email"),
            Doctor.id.label("doctor_id"),
            Doctor.full_name.label("doctor_full_name"),
            Doctor.specialty.label("doctor_specialty"),
        )
        .join(Patient)
        .join(Doctor)
    )

    if doctor_id:
        stmt = stmt.where(Appointment.doctor_id == doctor_id)

    if patient_id:
        stmt = stmt.where(Appointment.patient_id == patient_id)

    if date_str:
        try:
            target_date = date.fromisoformat(date_str)
        except ValueError:
            raise ValueError("Invalid date format. Use YYYY-MM-DD")

        start_dt = datetime.combine(
            target_date, datetime.min.time(), tzinfo=timezone.utc
        )
        end_dt = start_dt + timedelta(days=1)
        stmt = stmt.where(
            Appointment.appointment_start_datetime >= start_dt,
            Appointment.appointment_start_datetime < end_dt,
        )

    return db.execute(stmt).mappings().all()


def delete_appointment(db: Session, appointment_id: int):
    appointment = db.get(Appointment, appointment_id)
    if not appointment:
        return False

    db.delete(appointment)
    db.commit()
    return True


src/services/doctor_service.py:
from sqlalchemy.orm import Session
from models import doctor as models
from schemas import doctor_pydantic as sch
from sqlalchemy import select
from sqlalchemy.sql import func
from models.appointment import Appointment
from models.doctor import Doctor


def create_doctor(db: Session, doctor: sch.DoctorCreate):
    db_doctor = models.Doctor(
        full_name=doctor.full_name,
        specialty=doctor.specialty,
        active_status=doctor.active_status,
    )
    db.add(db_doctor)
    db.commit()
    db.refresh(db_doctor)
    return db_doctor


def read_doctor(db: Session, doctor_id: int):
    stmt = select(
        models.Doctor.id,
        models.Doctor.full_name,
        models.Doctor.specialty,
        models.Doctor.active_status,
        models.Doctor.created_at,
        models.Doctor.updated_at,
    ).where(models.Doctor.id == doctor_id)

    result = db.execute(stmt).mappings().one_or_none()
    return result


def read_all_doctors(db: Session):
    stmt = select(
        models.Doctor.id,
        models.Doctor.full_name,
        models.Doctor.specialty,
        models.Doctor.active_status,
        models.Doctor.created_at,
        models.Doctor.updated_at,
    )

    result = db.execute(stmt).mappings().all()
    return result


def toggle_status_doctor(db: Session, doctor_id: int):
    db_doctor = db.get(models.Doctor, doctor_id)
    if not db_doctor:
        return None
    if db_doctor.active_status:
        db_doctor.active_status = False
    else:
        db_doctor.active_status = True
    db.commit()
    db.refresh(db_doctor)
    return db_doctor

 
def delete_doctor(db: Session, doctor_id: int):
    doctor = db.get(Doctor, doctor_id)
    if not doctor:
        return None

    has_appointments = db.scalar(
        select(func.count())
        .select_from(Appointment)
        .where(Appointment.doctor_id == doctor_id)
    )

    if has_appointments > 0:
        raise ValueError("Doctor has appointments and cannot be deleted")

    db.delete(doctor)
    db.commit()
    return doctor


src/services/patient_service.py:
from sqlalchemy.orm import Session
from models import patient as models
from sqlalchemy import select
from schemas import patient_pydantic as sch
from sqlalchemy.sql import func
from models.appointment import Appointment
from models.patient import Patient


def create_patient(db: Session, patient: sch.PatientCreate):
    db_patient = models.Patient(
        first_name=patient.first_name,
        last_name=patient.last_name,
        email=patient.email,
        phone_number=patient.phone_number,
    )
    db.add(db_patient)
    db.commit()
    db.refresh(db_patient)
    return db_patient


def read_patient(db: Session, patient_id: int):
    stmt = select(
        models.Patient.id,
        models.Patient.first_name,
        models.Patient.last_name,
        models.Patient.email,
        models.Patient.phone_number,
        models.Patient.created_at,
        models.Patient.updated_at,
    ).where(models.Patient.id == patient_id)

    result = db.execute(stmt).mappings().one_or_none()
    return result


def read_all_patients(db: Session):
    stmt = select(
        models.Patient.id,
        models.Patient.first_name,
        models.Patient.last_name,
        models.Patient.email,
        models.Patient.phone_number,
        models.Patient.created_at,
        models.Patient.updated_at,
    )
    result = db.execute(stmt).mappings().all()
    return result


def delete_patient(db: Session, patient_id: int):
    patient = db.get(Patient, patient_id)
    if not patient:
        return None

    has_appointments = db.scalar(
        select(func.count())
        .select_from(Appointment)
        .where(Appointment.patient_id == patient_id)
    )

    if has_appointments > 0:
        raise ValueError("Patient has appointments and cannot be deleted")

    db.delete(patient)
    db.commit()
    return patient
